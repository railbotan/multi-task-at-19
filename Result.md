# Отчет по работе «Параллелизм и асинхронность»
IO-BOUND
Время работы IO_bound.py при синхронной проверке ссылок – 10057 ms

![alt text](Pic/a1.png)

Перепишем код, используя ThreadPoolExecutor. Благодар этому время работы изменилось.
Когда количество воркеров(потоков):
5 - 5460 ms
![alt text](Pic/a2.png)
10 - 4736 ms
![alt text](Pic/a3.png)
100 - 4176 ms
![alt text](Pic/a4.png)

Таким образом, при увеличение количества потоков,  увеличение используемой памяти и загрузки процессора не происходит, и при этом дает выигрыш в скорости (времени) выполнения кода.

#CPU-BOUND
Время генерации четырех монет - 162764 ms
![alt text](Pic/c1.png)
Перепишем код используя ProcessPoolExecutor. 
При max_workers=2 время работы - 125920 ms
![alt text](Pic/c2.png)
При max_workers=4 время работы - 71804 ms
![alt text](Pic/c3.png)
При max_workers=5 время работы - 61158 ms
![alt text](Pic/c4.png)
При max_workers=10 время работы - 57459 ms
![alt text](Pic/c5.png)
При max_workers=100 время работы - 71784 ms
![alt text](Pic/c6.png)
Увеличение количества процессов влечет за собой увеличение используемой памяти и загрузки процессора, но при этом дает выигрыш в скорости (времени) выполнения кода, если количество процессов не превышает числа физических ядер
